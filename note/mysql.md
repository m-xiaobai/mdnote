# 索引

## 什么是索引

简单说索引其实就是数据的目录，帮助我们查找数据

1. 在一个页内查找：数据页内的记录是按照主键的顺序排成单链表的，可以用主键来进行二分查找

2. 多个页查找：为每个数据页建立一个目录，目录项就是**每个页最小的主键值以及页号**，先根据目录查找到属于哪一个页，再页内查找，**目录就是索引**

回表：二级索引只能获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。**这个过程叫「回表」**

覆盖索引：二级索引中存在要查询的数据，不用回表的过程

## 索引下推

MySQL索引下推（Index Condition Pushdown ICP）是从 MySQL 5.6 开始引入的一种查询优化技术。

⒈ ICP 简介

- ICP 是一种对通过索引查询数据的优化

- 如果不使用 ICP，存储引擎首先将通过索引定位到的行全部返回给 MySQL 服务端，服务端再通过 where 条件筛选符合条件的数据

- 开启 ICP 后，如果部分 where 条件可以通过索引中的列来筛选，则 MySQL 服务端会将这些 where 条件下推到存储引擎，存储引擎会通过索引对这些条件进行筛选，最后返回符合条件的行

- ICP 可以降低 MySQL 服务端访问存储引擎的次数，也可以降低存储引擎访问数据表的次数

作者：YanChen11  
链接：https://juejin.cn/post/6844904015633842183  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 聚处索引与二级索引

### 聚处索引

1. 页内的记录按照主键大小顺序排成单向链表

2. 页与页之间根据主键大小顺序排成双向链表（数据页和目录页）

3. B+树的叶子节点存放的是完整的用户记录

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/2023-08-01-21-28-25-image.png)

### 二级索引

- 页内的记录按照索引列大小顺序排成单向链表

- 页与页之间根据索引列大小顺序排成双向链表（数据页和目录页）

- B+树的叶子节点存放的不是完整的用户记录，而是索引列+主键

- 目录项记录不再是主键+页号，而是索引列+页号

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/2023-08-01-21-29-33-image.png)

## B+树

B树VS B+树

1. B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数；而B+树只在叶子节点上存储数据，非叶子节点是索引

2. 另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

3. 

## 索引优化方法

覆盖索引优化：将我们要查找的数据设置索引，在二级索引就找到所需数据，就无须回表

主键索引自增：**如果我们使用自增主键**，**插入一条新记录，都是追加操作，不需要重新移动数据**，如果使用非自增主键有可能造成页分裂

看下面sql优化

## 索引失效

- 当我们对索引使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

> [MySQL单列索引与多列索引的区别 - 迷糊桃 - 博客园 (cnblogs.com)](https://www.cnblogs.com/mihutao/p/17026942.html)

# 事务

## 事务操作

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/5.png)

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/6.png)

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/7.png)

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/8.png)

## 事务特性

事务的四大特性：

1. **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成

2. **一致性（Consistency）**：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。转账前后两个账户的总数是一样的

3. **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力

4. **持久性（Durability）**：一旦提交事务后，对数据的修改就是永久的

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

## 事务隔离级别

<mark>事务并发执行遇到的问题</mark>

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/1.png)

> 脏读中的修改可以是update,insert,delete
> 
> 注意：幻读主要是指其他事务插入，幻读是读取到之前没读取到的数据

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/2.png)

> 可重复读不能避免幻读，但是mysql中的innodb引擎**很大程度上避免幻读现象**

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/3.png)

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/4.png)

> Mysql8查询会话隔离级别为：transaction_isolation 

<mark>可重复读</mark>解决幻读的方案：

1. 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**

2. 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**

但是MVCC不能完全解决幻读问题：一个事务执行查询语句，另一个事务插入一条新纪录后提交，`事务再对这条记录进行update操作`，记录中的trx_id就变成了当前事务，再去执行查询语句这条新记录就可见

## MVCC原理

<mark>聚簇索引</mark>记录中的两个隐藏列

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/9.png)

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的<mark>记录</mark>写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

> 也就是说undo 日志中~~存放的是旧版本的记录~~，他也有trx_id

ReadView

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/10.png)

Read View 有四个重要的字段：

- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/11.png)

**判断记录的某个版本是否可见的步骤**：

+ 如果记录的trx_id和ReadView中的creator_trx_id相同，意味着当前事务访问它自己修改过的记录，该版本对当前事务可见
- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示生成该版本的事务在当前事务生成Read View前已经提交，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示生成该版本的事务在当前事务生成Read View后才开启，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的 `min_trx_id` 和 `max_trx_id` 之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）**

ReadView生成时机：

+ **读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**。

+ **可重复读隔离级别是在第一次读取数据时生成一个 Read View，然后整个事务期间都在用这个 Read View**。之后的查询就不会重复生成Reda View

## innodb与myisam区别

+ myisam没有事务，innodb有事务

+ Myisam只支持表级锁，而Innodb还能支持行级锁

# 锁

多个未提交事务同时对一条记录进行改动时，需要让他们排队执行（同时执行为脏写，不允许），这个排队执行是通过为该记录加锁来实现的，锁其实是一个`内存中的结构` ，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构 和记录进行关联的

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条**记录**关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个锁结构与之关联

锁结构信息（重要的）：

- trx信息：表示这个锁结构与哪个事务关联

- is_waiting：表示当前事务是否在等待

在T1提交前，T2也想修改，也生成锁结构，is_waiting为true，不过要等待

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/2023-08-03-10-37-38-image.png)

## 锁分类

### S锁和X锁

+ 读锁 ：也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。
  
  + 加锁方式：
    
    ```sql
    select ... lock in share mode
    ```

+ 写锁 ：也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入
  
  + 加锁方式：
    
    ```sql
    select ... for update 
    ```

前面提到的锁是行级锁，对记录加锁，也可以对表加锁，**表锁**也有读锁和写锁

### 表锁

#### 意向锁

+ 意向共享锁（IS锁）：当事务准备在某条记录上加S锁时，需要先在表中加一个IS锁

+ 意向独占锁（IX锁）：当事务准备在某条记录上加X锁时，需要现在表中加一个IX锁

IS锁和IX锁是表级锁，提出仅仅是为了之后在表级别的读锁和写锁可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录；IS锁和IX锁之间是可以兼容的

意向锁之间互不排斥，但除了 IS 与 S（表级） 兼容外， 意向锁会与 共享锁 / 排他锁（表级） 互斥 。

### 行锁

#### 记录锁 Record Lock

普通的记录锁，对某一条记录加锁

#### 间隙锁 Gap Lock

比如id值为8的记录加了gap锁，意味着 `不允许别的事务在id值为8的记录前边的间隙`插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的（3是8的前一条记录）。比如，有另外一个事务再想插入一条id值为4的新记录，它**定位到该条新记录的下一条记录**的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。

**间隙锁的目的仅仅是为了防止插入幻影记录**

#### Next-Key Lock

本质是一个Record Lock和gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入到被保护的记录前面的间隙中

#### 插入意向锁

一个事务在插入一条记录时，需要判断插入位置是否已经被别的事务加了gap锁，如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止，在此期间会生成一个**插入意向锁**

## 加锁分析

查找过程中<mark>访问到的对象</mark>才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终
都要回溯到主键上，在主键上也要加一把锁。（如果不用回到主键自然也不需要加锁）

对于for update share mode这两种分析，一般情况下

+ 隔离级别不大于读已提交，加普通记录锁

+ 隔离级别不小于可重复读，加next-key锁

特殊情况：（**在可重复读下**）

唯一索引等值查询（也就是说结果至多有一个）：

- 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会**退化成「记录锁」**。
- 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会**退化成「间隙锁」**。

非唯一索引等值查询：

- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的<mark>二级索引记录</mark>加的是 next-key 锁，而对于<mark>第一个不符合条件的二级索引记录</mark>，该二级索引的 next-key 锁会退化成间隙锁。同时，在<mark>符合查询条件的记录的主键索引</mark>上加记录锁。
- 当查询的记录「不存在」时，**扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁**

非唯一索引和主键索引的范围查询的加锁规则不同之处在于：

- 唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。
- 非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。（也就是加的是next-key lock）

# 日志

## undo log

undo log 是一种用于撤销回退的日志,每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把**回滚时需要的信息**都记录到 undo log 里

作用：

- **实现事务回滚，保障事务的原子性**。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到**事务开始之前**的状态。
- **实现 MVCC（多版本并发控制）关键因素之一**。MVCC 是通过 ReadView + undo log 实现的

### redo log

redo log 是物理日志，记录了某个数据页做了什么修改，在事务提交时，只要先将 redo log 持久化到磁盘即可

刷盘时机：

+ 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时

+ InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。

+ 事务提交时

+ 正常关闭服务器

与undo log的联系

- redo log 记录了此次事务「**完成后**」的数据状态，记录的是更新**之后**的值；
- undo log 记录了此次事务「**开始前**」的数据状态，记录的是更新**之前**的值；

事务<mark>提交之前</mark>发生了崩溃，重启后会通过 undo log 回滚事务，事务<mark>提交之后</mark>发生了崩溃，重启后会通过 redo log 恢复事务，如下图：

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/trx.png)

### bin log

binlog 文件是记录了`所有数据库表结构变更和表数据修改`的日志，不会记录查询的操作（默认是sql语句）

与redo log的区别

*1、适用对象不同：*

- binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；
- redo log 是 Innodb 存储引擎实现的日志；

*2、写入方式不同：*

- binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。
- redo log 是循环写，日志空间大小是固定，全部写满就从头开始

*3、用途不同：*

- binlog 用于备份恢复、主从复制；
- redo log 用于<mark>掉电等故障恢复</mark>。

主从复制

这个过程一般是**异步**的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。

![](https://markdown-m.oss-cn-hangzhou.aliyuncs.com/mysql/copy.png)

- 写入binlog：MySQL 主库在收到客户端提交事务的请求之后，会先`写入 binlog`，再`提交事务`，更新存储引擎中的数据，发送binlog给从库
- 同步binlog：从库会`创建一个专门的 I/O 线程`，连接主库的 log dump 线程，来`接收主库的 binlog 日志`，再把 binlog 信息`写入 relay log 的中继日志`里，再返回给主库“复制成功”的响应。
- 回放binlog：从库会创建一个用于<mark>回放 binlog 的线程</mark>，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。

# sql优化

## 慢查询如何优化

慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？

1. 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。

2. 分析语句的执行计划(EXPLAIN)，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
   
   exlplain字段(重要)有：
   
   select_type：查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询
   
   key ：表示 MySQL 实际使用到的索引，也就是哪个列使用到索引。如果为 NULL，则表示未用到索引。
   
   type：查询执行的类型，描述了查询是如何执行的。
   
   - **const**：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。
   - **ref**：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。
   - **range**：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。
   - **ALL**：全表扫描

3. 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

## 关联查询优化

1. 保证<mark>被驱动表</mark>的 JOIN 字段已经创建了索引（减少内层表的循环匹配次数）
2. 需要 JOIN 的字段，数据类型保持绝对一致。
3. LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。
4. INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表 。选择相信 MySQL 优化策略。
5. 能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)
6. 不建议使用多层嵌套子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询。
7. 衍生表建不了索引
8. 默认效率比较：INLJ > BNLJ > SNLJ
9. 正确理解小表驱动大表：大小不是指表中的记录数，而是永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）。 比如A表有100条记录，B表有1000条记录，但是where条件过滤后，B表结果集只留下50个记录，A表结果集有80条记录，此时就可能是B表驱动A表。其实上面的例子还是不够准确，因为结果集的大小也不能粗略的用结果集的行数表示，而是表行数 *每行大小。其实要理解你只需要结合Join Buffer就好了，因为表行数* 每行大小越小，其占用内存越小,就可以在Join Buffer中尽量少的次数加载完了。

[26_mysql数据库优化之关联查询优化与JOIN原理-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1089837)

## 表设计

遵循三范式：

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。
- 第三范式：任何非主属性不依赖于其它非主属性。
